from flask import Blueprint, request, jsonify
from datetime import datetime, timedelta
import threading

from app.middleware.auth import token_required, get_user_id
from app.models.exam import Exam
from app.models.question import Question
from app.services.gemini_service import GeminiService
from app.services.firebase_service import FirebaseService
from app.utils.response import success_response, error_response
from app.utils.cache import question_cache

# Create blueprint
exam_bp = Blueprint('exams', __name__)

@exam_bp.route('/exams/create', methods=['POST'])
@token_required
def create_exam():
    """Create a new exam with questions generated by Gemini"""
    try:
        # Get request data
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['examType', 'questionCount', 'estimatedTime', 'contentSelection']
        for field in required_fields:
            if field not in data:
                return error_response(f"Campo obrigatório ausente: {field}", "MISSING_FIELD")
        
        # Validate question count
        question_count = data.get('questionCount')
        if not isinstance(question_count, int) or question_count < 3 or question_count > 30:
            return error_response(
                "Número de questões inválido. Deve estar entre 3 e 30.",
                "INVALID_QUESTION_COUNT"
            )
        
        # Get user ID from token
        user_id = get_user_id()
        
        # Create exam object
        exam = Exam(
            user_id=user_id,
            exam_type=data.get('examType'),
            question_count=question_count,
            estimated_time=data.get('estimatedTime'),
            content_selection=data.get('contentSelection')
        )
        
        # Generate questions synchronously (no background thread)
        try:
            # Generate questions using Gemini
            questions = GeminiService.generate_questions_with_cache(
                content_selection=data.get('contentSelection'),
                question_count=question_count,
                user_id=user_id,
                cache=question_cache
            )
            
            # Save questions to Firestore as separate documents
            saved_questions = Question.save_batch(questions, user_id)
            
            # Update exam with question IDs and status
            question_ids = [q.id for q in saved_questions]
            exam.question_ids = question_ids
            exam.status = "ready"
            exam.save()
            
            # Return response with exam details including questions
            return success_response(
                {"exam": exam.to_response_dict(include_questions=True)},
                "Simulado criado com sucesso.",
                201
            )
        except Exception as e:
            print(f"Error generating questions: {e}")
            # Update exam status to indicate error
            exam.status = "error"
            exam.save()
            return error_response(
                "Erro ao gerar questões. Por favor, tente novamente.",
                "QUESTION_GENERATION_ERROR",
                500
            )
    except Exception as e:
        print(f"Error creating exam: {e}")
        return error_response(
            "Erro ao criar simulado. Por favor, tente novamente.",
            "INTERNAL_SERVER_ERROR",
            500
        )
    except Exception as e:
        print(f"Error creating exam: {e}")
        return error_response(
            "Erro ao criar simulado. Por favor, tente novamente.",
            "INTERNAL_SERVER_ERROR",
            500
        )

@exam_bp.route('/exams/<exam_id>', methods=['GET'])
@token_required
def get_exam(exam_id):
    """Get exam details by ID"""
    try:
        # Get user ID from token
        user_id = get_user_id()
        
        # Get exam from Firestore
        exam = Exam.get_by_id(exam_id, user_id)
        
        if not exam:
            return error_response("Simulado não encontrado.", "EXAM_NOT_FOUND", 404)
        
        # Return exam details
        return success_response({"exam": exam.to_response_dict()})
    except Exception as e:
        print(f"Error getting exam: {e}")
        return error_response(
            "Erro ao obter detalhes do simulado.",
            "INTERNAL_SERVER_ERROR",
            500
        )

@exam_bp.route('/exams/<exam_id>/start', methods=['POST'])
@token_required
def start_exam(exam_id):
    """Start an exam and set its status to in-progress"""
    try:
        # Get user ID from token
        user_id = get_user_id()
        
        # Get exam from Firestore
        exam = Exam.get_by_id(exam_id, user_id)
        
        if not exam:
            return error_response("Simulado não encontrado.", "EXAM_NOT_FOUND", 404)
        
        # Check if exam is in a valid state to start
        if exam.status != "ready":
            if exam.status == "generating":
                return error_response(
                    "O simulado ainda está sendo gerado. Por favor, aguarde.",
                    "EXAM_GENERATING",
                    400
                )
            elif exam.status == "in-progress":
                return error_response(
                    "Este simulado já está em andamento.",
                    "EXAM_ALREADY_STARTED",
                    400
                )
            elif exam.status == "completed":
                return error_response(
                    "Este simulado já foi concluído.",
                    "EXAM_ALREADY_COMPLETED",
                    400
                )
            elif exam.status == "expired":
                return error_response(
                    "Este simulado expirou.",
                    "EXAM_EXPIRED",
                    400
                )
        
        # Set start time and end time
        start_time = datetime.utcnow()
        end_time = start_time + timedelta(minutes=exam.estimated_time)
        
        # Update exam status
        exam.status = "in-progress"
        exam.start_time = start_time
        exam.end_time = end_time
        exam.save()
        
        # Return success response
        return success_response({
            "startTime": start_time.isoformat() + "Z",
            "endTime": end_time.isoformat() + "Z"
        }, "Simulado iniciado com sucesso.")
    except Exception as e:
        print(f"Error starting exam: {e}")
        return error_response(
            "Erro ao iniciar simulado.",
            "INTERNAL_SERVER_ERROR",
            500
        )

@exam_bp.route('/exams/<exam_id>/submit', methods=['POST'])
@token_required
def submit_exam(exam_id):
    """Submit answers for an exam and calculate results"""
    try:
        # Get user ID from token
        user_id = get_user_id()
        
        # Get request data
        data = request.get_json()
        
        # Validate answers
        answers = data.get('answers')
        if not answers or not isinstance(answers, list):
            return error_response("Formato de respostas inválido.", "INVALID_ANSWERS_FORMAT", 400)
        
        # Get exam from Firestore
        exam = Exam.get_by_id(exam_id, user_id)
        
        if not exam:
            return error_response("Simulado não encontrado.", "EXAM_NOT_FOUND", 404)
        
        # Check if exam is in progress
        if exam.status != "in-progress":
            if exam.status == "completed":
                return error_response(
                    "Este simulado já foi finalizado.",
                    "EXAM_ALREADY_COMPLETED",
                    400
                )
            elif exam.status == "expired":
                return error_response(
                    "Este simulado expirou.",
                    "EXAM_EXPIRED",
                    400
                )
            else:
                return error_response(
                    "Este simulado não está em andamento.",
                    "EXAM_NOT_STARTED",
                    400
                )
        
        # Calculate time spent
        start_time = getattr(exam, 'start_time', None)
        if start_time:
            time_spent = int((datetime.utcnow() - start_time).total_seconds() / 60)
        else:
            time_spent = exam.estimated_time  # Fallback if start_time not set
        
        # Fetch questions from the questions collection
        from app.models.question import Question
        questions = Question.get_by_ids(exam.question_ids)
        
        # Calculate score
        total_questions = len(questions)
        correct_answers = 0
        
        # Create a map of question IDs to correct answers
        question_map = {q.id: q.correct_answer for q in questions}
        
        # Check answers
        for answer in answers:
            question_id = answer.get('questionId')
            selected_option = answer.get('selectedOption')
            
            if question_id in question_map and question_map[question_id] == selected_option:
                correct_answers += 1
        
        # Calculate score (0-10 scale)
        score = (correct_answers / total_questions) * 10 if total_questions > 0 else 0
        
        # Save result to Firestore
        FirebaseService.save_exam_result(
            exam_id=exam_id,
            user_id=user_id,
            answers=answers,
            score=score,
            time_spent=time_spent
        )
        
        # Return result
        return success_response({
            "result": {
                "score": round(score, 1),
                "totalQuestions": total_questions,
                "correctAnswers": correct_answers,
                "incorrectAnswers": total_questions - correct_answers,
                "timeSpent": time_spent,
                "redirectUrl": f"/exam/result/{exam_id}"
            }
        }, "Simulado avaliado com sucesso.")
    except Exception as e:
        print(f"Error submitting exam: {e}")
        return error_response(
            "Erro ao avaliar simulado.",
            "INTERNAL_SERVER_ERROR",
            500
        )

@exam_bp.route('/exams/user/history', methods=['GET'])
@token_required
def get_user_exams():
    """Get exam history for the authenticated user"""
    try:
        # Get user ID from token
        user_id = get_user_id()
        
        # Get query parameters
        page = int(request.args.get('page', 1))
        limit = int(request.args.get('limit', 10))
        status = request.args.get('status')
        
        # Validate page and limit
        if page < 1:
            page = 1
        if limit < 1 or limit > 50:
            limit = 10
        
        # Get exams from Firestore
        result = Exam.get_user_exams(user_id, status, page, limit)
        
        # Format response
        exams_data = []
        for exam in result['exams']:
            exam_data = {
                "id": exam.id,
                "title": exam.title,
                "createdAt": exam.created_at.isoformat() + "Z",
                "status": exam.status,
                "questionCount": exam.question_count
            }
            
            # Add score if exam is completed
            if exam.status == "completed":
                # This would normally come from the exam_results collection
                # For simplicity, we're using a placeholder
                exam_data["score"] = getattr(exam, 'score', None)
            
            exams_data.append(exam_data)
        
        # Return response
        return success_response({
            "exams": exams_data,
            "pagination": result['pagination']
        })
    except Exception as e:
        print(f"Error getting user exams: {e}")
        return error_response(
            "Erro ao obter histórico de simulados.",
            "INTERNAL_SERVER_ERROR",
            500
        )
